# Think React!

This tutorial is inspired by the classic [Thinking in React](https://facebook.github.io/react/docs/thinking-in-react.html)
tutorial.  I've updated it to run as a [create-react-app](https://github.com/facebookincubator/create-react-app)
project and added extensive new material to serve as a thorough introduction to
React and it's ecosystem.

###### Disclaimer
> I assume that you already have a good foundational understanding of JavaScript
> and web development. You should be very familiar with variables and loops,
> arrays and objects, HTML, CSS and the DOM. I expect that you've at least heard
> of slightly more advanced concepts like AJAX and RESTful API's. If those things
> don't make sense to you yet, that's ok!  This tutorial might just be a bit hard
> to follow. One of my favorite resources for learning JavaScript is the book
> [Eloquent JavaScript](http://eloquentjavascript.net/) which you can read for
> free online. Study up and come back when you're ready. (or if you like a
> challenge, try working your way through this tutorial anyway!)

## Setup Instructions
I assume that you already have [git](https://git-scm.com/) and [node.js](https://nodejs.org)
installed on your computer.  The steps to get this project running are simple:

 - Clone this project: `git clone https://github.com/Traviskn/think-react.git`
 - Move into the project folder and install dependencies: `cd think-react && npm install`
 - Start up the development server: `npm start`

Open up [http://localhost:3000](http://localhost:3000) in your favorite web
browser and you should be good to go!

## Part 1 - Hello React!

What you are looking at now is a basic skeleton generated by `create-react-app`.
Let's read over the code here to get a whirlwhind tour of React! As we work
through learning React together, we will slowly transform this code into a basic
shopping app. Let's get started!

First take a look at the `src/index.js` file.  This is the entry point for our app:

```javascript
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(<App />, document.getElementById('root'));
```

### Build Tools

Those `import` statements at the top are pulling in code from other files.
Normally JavaScript doesn't have this ability, so how are we able to do it here?
`create-react-app` has configured a tool for us called [Webpack](https://webpack.js.org/)
that enables us to write our code in many separate files and `import` those code
files when we need them. You'll notice we can even import a CSS file!  Webpack
will do some extra work under the hood to make sure that CSS is injected into the
page. Build tools like Webpack are very powerful, but also very complicated.
When learning React for the first time it is better to focus _just_ on React and
not worry too much about the build tools running under the hood. Just know that
in a `create-react-app` project we have all the power of Webpack and a modern
JavaScript development environment ready to go for us!

### React project structure

Look at that last line starting with `ReactDOM.render`.  This method is what puts
your React app into an HTML page.  It's using standard DOM APIs to find an HTML
element with an id of `root`, and rendering your app there.  Open up `public/index.html`
to see the HTML file this project is using. Around line 28 you'll see this:
`<div id="root"></div>`. That div is where your React app will live!

And what is `ReactDOM` rendering into that `root` div tag?  It's rendering an
`<App />` component!  The `<App />` component will contain all of the other components
that we use to build out the rest of our app. The syntax there may look a little
strange though, almost like a custom HTML element. What is that `<App />` element?
Open up `src/App.js` to find out.

### Essential syntax

```javascript
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  render() {
    return (
      <div className="App">
        <div className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h2>Welcome to React</h2>
        </div>
        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>
    );
  }
}

export default App;
```

Look at that!  The App component is a JavaScript class. React embraces modern,
future facing JavaScript features like classes.  Classes, as well as a host of
other features, were introduced to the JavaScript language as part of [ES6](http://exploringjs.com/es6/index.html),
or the 6th revision of the language spec. You may be concerned
about compatibility of these new language features with older browsers.  As a part
of Webpack, `create-react-app` has configured a build tool called [Babel](https://babeljs.io/)
that will transform our code into a backwards compatible form that can run in
older browsers. This means that we can freely use modern features like classes,
arrow functions, and more in our app.

The component class has a single `render` method that looks like it returns...
HTML?!?  Don't get too confused by the unfamiliar syntax here.  `create-react-app`
has configured the build tools to handle it for us. For now, take a step back
and think about how natural this actually is.  A React component is a JavaScript
class that renders HTML.  `div` tags, `p` tags, all familiar stuff.  The only
unfamiliar HTML attributes here are those `className` attributes, which are an
attempt to avoid clashing with the built-in `class` keyword in JavaScript. If
you inspect the HTML in your browser, you'll see it matches up with the code
here in our component. Try editing the text in the `<p>` tags and watch your
changes appear in the browser!  Try adding some different HTML if you like. React
components will render whatever you need them to!

## Part 2 - JSX

This HTML-like syntax in our React component is called [JSX](https://facebook.github.io/react/docs/introducing-jsx.html).
JSX obviously isn't valid JavaScript, but as part of our build process Babel will
transform it into valid JavaScript.

JSX is probably the most well-known and controversial feature of React. Let's
take a step back from the strange syntax to understand what is going on under
the hood.

Every JSX element simply gets transformed into a call to the `React.createElement`
function at build time.

For example, if you write this `render` function:

```javascript
render() {
  return <h1 className="header">Hello World</h1>;
}
```

Then it will look like this once Babel is done with it:

```javascript
render() {
  return React.createElement(
    'h1',
    { className: 'header' },
    'Hello World'
  );
}
```

As it turns out, you don't even need to use JSX in your React components if you
don't want to! In fact as part of our learning exercise, we will go ahead and write
a bunch of React code without it to ensure we understand plain vanilla React.

### Looping with map
Let's use React to render a list of products for our shopping app.  Go to the
`render` method of the App component in `src/App.js`, and change it to look
like this:

```javascript
render() {
  return (
    <ul>
      <li>Baseball</li>
      <li>Football</li>
      <li>Basketball</li>
    </ul>
  );
}
```

You should now see those three bulleted list items in your browser.  Let's take
away the JSX, and rewrite it using React's `createElement` functions.

```javascript
render() {
  return React.createElement('ul', null,
    React.createElement('li', null, 'Baseball'),
    React.createElement('li', null, 'Football'),
    React.createElement('li', null, 'Basketball'),
  );
}
```

This code should render the exact same HTML as before in your browser. Remember
that JSX is simply syntactic sugar for `React.createElement`.

How do we more dynamically render list items though? Perhaps based on an array
of product data we fetch from a server?  We can use `map`!  Change your render
function to match the code below:

```javascript
render() {
  const products = ['Baseball', 'Football', 'Basketball'];

  return React.createElement('ul', null,
    products.map(data => React.createElement('li', null, data))
  );
}
```

What we've done here is taken an array of products, and mapped over it to produce an
array of list item elements!  You should see the list of products in the browser.
Here's how you would write the equivalent code in JSX:

```javascript
render() {
  const products = ['Baseball', 'Football', 'Basketball'];

  return (
    <ul>
      {products.map(data =>
        <li>
          {data}
        </li>
      )}
    </ul>
  );
}
```

Notice the use of curly braces `{}` in the JSX version.  Curly braces are used
to switch to normal JavaScript syntax in JSX.  We use the first pair of curly
braces to use the map method on our products array.  Inside our map callback,
we seamlessly use JSX again to create `<li>` elements.  Then, within the `<li>`
elements, we use _another_ set of curly braces to put in the value of our data
variable.  This is a good example of how you can use JSX and curly braces to
switch back and forth between JSX mode, and normal JavaScript mode. It might seem
a little confusing at first, but it is very similar to how other templating
languages use curly braces to interpolate JavaScript into HTML.

#### Keys

If you open up your JavaScript developer tools in your browser, you will notice
a few warnings.  Look at the one with this message:

`Each child in an array or iterator should have a unique "key" prop`

What does this mean?  Whenever React renders an array of elements, it needs to
use unique keys to keep track of them and re-render efficiently when they change.
It is important to remember that the key needs to be unique for each element,
because if the keys don't change then React will assume it doesn't need to
re-render anything.  You might be tempted to simply use array indices as keys,
but this will cause bugs because if your data changes or is re-ordered. The keys
will remain the same and no changes will be rendered!  Since our data is simply
text, and the text is unique, we can use the product itself as the key. In a more
realistic situation, you would want to be sure that all your data has some kind
of unique ID that you can use as a key.

Here's an example of adding in a key to get rid of the warning, showing first the
JSX and then the equivalent `createElement` syntax:

```javascript
render() {
  const products = ['Baseball', 'Football', 'Basketball'];

  // JSX Syntax
  return (
    <ul>
      {products.map(product=>
        <li key={product}>
          {product}
        </li>
      )}
    </ul>
  );

  // createElementSyntax
  return React.createElement('ul', null,
    products.map(product =>
      React.createElement('li', { key: product }, product)
    )
  );
}
```

#### Why not use a for loop?
You may think that you could just use a normal `for` loop in your JSX, but you'd
be wrong. Let's try to use a for loop here:

```javascript
render() {
  const products = ['Baseball', 'Football', 'Basketball'];

  return (
    <ul>
      {for(let product in products) { // Syntax error: unexpected token
        return (
          <li>
            {product}
          </li>
        );
      }
    </ul>
  );
}
```

You may initially be confused to get a syntax error, but the key to understanding
why is to think about how the code will be transformed into `createElement`
function calls. Let's translate that JSX:

```javascript
render() {
  const products = ['Baseball', 'Football', 'Basketball'];

  return React.createElement('ul', null,
    for(let product in products) { // Syntax error: unexpected token
      return React.createElement('li', { key: product }, product)
    }
  );
}
```

Is the `Syntax error: Unexpected token` message less confusing now? Passing for
loops as arguments to functions just doesn't make any sense. That's why using
loops in JSX is invalid. However, there is no reason you couldn't use a for loop
to build up an array of elements before returning your JSX. You still have all
the power of JavaScript in your `render` function:

```javascript
render() {
  const products = ['Baseball', 'Football', 'Basketball'];

  const listItems [];
  for(let product in products) {
    listItems.push(<li key={product}>{product}</li>);
  }

  return (
    <ul>
      {listItems}
    </ul>
  );
}
```

In most cases where you need to render UI based on an array of data, simply using
`Array.map` is all you need.

### Conditional logic

Many developers get frustrated learning React because using an `if` statement in
JSX is a syntax error. This is for the same reason that using a `for` loop is a
syntax error.  You can't pass an `if` statement as an argument to a function.

Instead of `if` statements, you can use logical operators like `&&`. Here is an
example of conditionally rendering a message only if a user is logged in, showing
first the JSX and then the equivalent`createElement` syntax:

```javascript
render() {
  const loggedIn = true;

  // JSX
  return (
    <div>
      <h1>Super Shopper</h1>

      {loggedIn && (
        <p>You are logged in!</p>
      )}
    </div>
  );

  // createElement
  return React.createElement('div', null,
    React.createElement('h1', null, 'Super Shopper'),
    loggedIn && React.createElement('p', null, 'You are logged in!')
  );
}
```

Change the `loggedIn` variable in the code to false, and see that the message
dissappears.

You can also use ternaries. Here is an example of a button that says "Log In" if
you are not logged in, and "Log Out" if you are already logged in, showing first
the JSX and then the `createElement` syntax.

```javascript
render() {
  const loggedIn = true;

  // JSX
  return (
    <div>
      <h1>Super Shopper</h1>

      <button>
        {loggedIn ? (
          "Log Out"
        ) : (
          "Log In"
        )}
      </button>
    </div>
  );

  // createElement
  return React.createElement('div', null,
    React.createElement('h1', null, 'Super Shopper'),
    React.createElement('button', null, loggedIn ? 'Log Out' : 'Log In')
  );
}
```

Change the `loggedIn` variable in the code back and forth between false and true,
and see that the text within the button changes accordingly.

You might not feel too happy about this situation.  We like `if` statements, and
often they read better than ternaries or logical operators.  The final solution
I offer for managing conditional logic is simply a function. You can break your
UI down into smaller functions that use `if` statements to decide what to return.
Here's an example:

```javascript
renderButton(loggedIn) {
  if (loggedIn) {
    return <button>Log Out</button>;
  } else {
    return <button>Log In</button>;
  }
}

render() {
  const loggedIn = true;

  // JSX
  return (
    <div>
      <h1>Super Shopper</h1>
      {this.renderButton(loggedIn)}
    </div>
  );

  // createElement
  return React.createElement('div', null,
    React.createElement('h1', null, 'Super Shopper'),
    this.renderButton(loggedIn)
  );
}
```

If you are ever feeling limited by JSX, remember that under the hood it's just
function calls, and you still have all the power of JavaScript functions at your
disposal.

### Conclusion

We have written a lot of JSX, and a lot of `createElement` function calls. Which
syntax do you prefer?  You are free to use whichever style suits you best. I will
say though that in the React community, using JSX is far more common and idiomatic
than using raw `createElement` calls.  As a React developer, you will be expected
to be able to read and understand both. For the remainder of this tutorial, I will
stick to JSX syntax, and leave converting it to `createElement` syntax as an
exercise for the reader. If you're still a little fuzzy on JSX, check out the
[official docs](https://facebook.github.io/react/docs/jsx-in-depth.html).

# Work In Progress
The rest of this tutorial is still a work in progress, stay tuned for updates!

## Part 3 - Props

So far we have been restricting ourselves to a single component's `render` function.
It's time to see how data flows between many components!

If you think of react components as functions that render UI, you can think of
props as the arguments passed to those functions. Let's create a new ProductList
component that we can use in our App.  Create a new file `src/ProductList.js` and
fill in the following code:
```javascript
```

## Part 4 - State

## Part 5 - Lifecycle Hooks

## Part 6 - Bringing it all together with data fetching

Ever heard of AJAX?  I would argue that JavaScript's ability to fetch data in the background without
reloading the page is the only reason JavaScript frameworks have become so popular.  Every JavaScript app
we build stands on a foundation of the data we get from our web servers!  It makes sense then that one of
the most important tasks you need to be able to do in React is fetch and manipulate data from a web server.
In order to perform data fetching effectively, we will need to use all of the knowledge we have gained so
far about component lifecycle hooks, props, and state.

For this tutorial I have already configured a simple web server for you to get data from.
Open up your browser and point it at [http://localhost:3004/products](http://localhost:3004/products)
and you should see some beautiful JSON data! Let's load it up in our React app.

### Initial data fetching in componentDidMount

### Storing data with setState

### Passing data down via props

### Paginating data



### Render and the Virtual DOM (Maybe make this a side discussion later on, maybe a performance section?)

### Classes and Composition (Maybe make this a side discussion later on)

## Part 7 Styling with CSS in JS
 - inline styles
 - styled-components/glamorous

## Part 8 - Add more pages with React Router

Did you know that the most used button in web browsers is the back button?  Navigating back and forth
between multiple pages and urls is how we use the internet!  With React Router, you too can add more pages
and urls to your app to let people navigate naturally.

## Part 9 - Advanced data management with Redux

So far we have been storing all of our data in our top level App.js component.  It has become almost like a
miniature database! The more data we shove into this component's state, the more difficult it will become
to manage.  Luckily, Redux offers a very clean, predictable, and scalable solution for managing lots of data
in React.

### Flux Architecture

### Store

### Actions

### Reducers

### React integration with Provider and connect

### Map state to props

### Map dispatch to props

### Immutability

### Middleware, what the thunk?

### Data formatting with selectors

## Bonus Round - Build a mobile app with React Native!

So far we have been building a web app together.  Believe it or not, you actually now have all the knowledge
you need to build mobile iOS and Android apps too!  Don't believe me?  Let me show you.

### Expo
 - All you need is a web browser and the expo app on your smartphone
